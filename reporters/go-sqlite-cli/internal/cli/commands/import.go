// Copyright 2025 Mihai Ungureanu
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/miun-personal-shadows/seed-go-sqlite-api/internal/database"
	"github.com/miun-personal-shadows/seed-go-sqlite-api/internal/importer"
	"github.com/spf13/cobra"
)

var (
	importDBPath      string
	importFile        string
	importDir         string
	inputDir          string
	processedDir      string
	discardsDir       string
	loadReference     bool
	referenceDir      string
	licenseTermsPath  string
	productCodesPath  string
)

// NewImportCmd creates the import command
func NewImportCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "import",
		Short: "Import inspector CSV files into the database",
		Long: `Import CSV files generated by the inspector into the license monitor database.

The import command supports:
- Single file import: --file <path>
- Directory import: --dir <path> (imports all .csv files)
- Folder-based workflow: --input-dir <path> (with automatic file movement)
- Automatic node creation if not exists
- Physical host tracking and aggregation
- Import audit trail
- Idempotent imports (upsert on duplicate)

Folder-based workflow:
  Files in input-dir are processed and moved to:
  - processed-dir on success
  - discards-dir on error

Example:
  # Import single file
  go-sqlite-cli import --db-path ./data/license-monitor.db --file ./iwdli_output_omis446_20251021_090906.csv

  # Import all files in directory (no file movement)
  go-sqlite-cli import --db-path ./data/license-monitor.db --dir ./input/

  # Import with folder workflow (files are moved after processing)
  go-sqlite-cli import --db-path ./data/license-monitor.db --input-dir ./test-data/input`,
		RunE: runImport,
	}

	cmd.Flags().StringVar(&importDBPath, "db-path", "data/license-monitor.db",
		"Path to the SQLite database file")
	cmd.Flags().StringVar(&importFile, "file", "",
		"Path to a single CSV file to import")
	cmd.Flags().StringVar(&importDir, "dir", "",
		"Directory containing CSV files to import (no file movement)")
	cmd.Flags().StringVar(&inputDir, "input-dir", "",
		"Input directory for folder-based workflow (files moved after processing)")
	cmd.Flags().StringVar(&processedDir, "processed-dir", "",
		"Processed files directory (default: <parent>/processed)")
	cmd.Flags().StringVar(&discardsDir, "discards-dir", "",
		"Discarded files directory (default: <parent>/discards)")
	cmd.Flags().BoolVar(&loadReference, "load-reference", false,
		"Load reference data (license terms and product codes) before importing")
	cmd.Flags().StringVar(&referenceDir, "reference-dir", "",
		"Directory containing reference CSV files (license-terms.csv and product-codes.csv)")
	cmd.Flags().StringVar(&licenseTermsPath, "license-terms", "",
		"Path to license-terms.csv file (overrides reference-dir)")
	cmd.Flags().StringVar(&productCodesPath, "product-codes", "",
		"Path to product-codes.csv file (overrides reference-dir)")

	return cmd
}

func runImport(cmd *cobra.Command, args []string) error {
	// Validate flags
	modeCount := 0
	if importFile != "" {
		modeCount++
	}
	if importDir != "" {
		modeCount++
	}
	if inputDir != "" {
		modeCount++
	}

	if modeCount == 0 {
		return fmt.Errorf("one of --file, --dir, or --input-dir must be specified")
	}
	if modeCount > 1 {
		return fmt.Errorf("only one of --file, --dir, or --input-dir can be specified")
	}

	// Check database exists
	if _, err := os.Stat(importDBPath); os.IsNotExist(err) {
		return fmt.Errorf("database does not exist at %s\nRun 'go-sqlite-cli init' first", importDBPath)
	}

	// Setup folder-based workflow if using input-dir
	var moveFiles bool
	var targetProcessedDir, targetDiscardsDir string
	if inputDir != "" {
		moveFiles = true
		
		// Determine processed and discards directories
		parentDir := filepath.Dir(inputDir)
		if processedDir == "" {
			targetProcessedDir = filepath.Join(parentDir, "processed")
		} else {
			targetProcessedDir = processedDir
		}
		
		if discardsDir == "" {
			targetDiscardsDir = filepath.Join(parentDir, "discards")
		} else {
			targetDiscardsDir = discardsDir
		}

		// Create directories if they don't exist
		if err := os.MkdirAll(inputDir, 0755); err != nil {
			return fmt.Errorf("failed to create input directory: %w", err)
		}
		if err := os.MkdirAll(targetProcessedDir, 0755); err != nil {
			return fmt.Errorf("failed to create processed directory: %w", err)
		}
		if err := os.MkdirAll(targetDiscardsDir, 0755); err != nil {
			return fmt.Errorf("failed to create discards directory: %w", err)
		}

		fmt.Printf("Folder-based workflow enabled:\n")
		fmt.Printf("  Input:     %s\n", inputDir)
		fmt.Printf("  Processed: %s\n", targetProcessedDir)
		fmt.Printf("  Discards:  %s\n", targetDiscardsDir)
		fmt.Println()
	}

	// Connect to database
	db, err := database.Connect(importDBPath)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	// Load reference data if requested
	if loadReference {
		// Determine paths for license terms and product codes
		var ltPath, pcPath string
		
		if referenceDir != "" {
			// Use reference directory
			ltPath = filepath.Join(referenceDir, "license-terms.csv")
			pcPath = filepath.Join(referenceDir, "product-codes.csv")
		}
		
		// Override with specific paths if provided
		if licenseTermsPath != "" {
			ltPath = licenseTermsPath
		}
		if productCodesPath != "" {
			pcPath = productCodesPath
		}
		
		// Validate that we have paths
		if ltPath == "" || pcPath == "" {
			return fmt.Errorf("--reference-dir or both --license-terms and --product-codes must be specified with --load-reference")
		}

		fmt.Println("Loading reference data...")
		loader := importer.NewReferenceDataLoader(db)
		
		// Load license terms first (product codes reference them)
		if _, err := os.Stat(ltPath); err == nil {
			fmt.Printf("Loading license terms from: %s\n", ltPath)
			if err := loader.LoadLicenseTermsCSV(ltPath); err != nil {
				return fmt.Errorf("failed to load license terms: %w", err)
			}
		} else {
			fmt.Printf("Warning: License terms file not found: %s\n", ltPath)
		}
		
		// Load product codes
		if _, err := os.Stat(pcPath); err == nil {
			fmt.Printf("Loading product codes from: %s\n", pcPath)
			if err := loader.LoadProductCodesCSV(pcPath); err != nil {
				return fmt.Errorf("failed to load product codes: %w", err)
			}
		} else {
			return fmt.Errorf("product codes file not found: %s", pcPath)
		}
		
		fmt.Println()
	}

	// Create import service
	service := importer.NewImportService(db)

	// Get list of files to import
	var files []string
	if importFile != "" {
		files = []string{importFile}
	} else if importDir != "" {
		files, err = findCSVFiles(importDir)
		if err != nil {
			return fmt.Errorf("failed to find CSV files: %w", err)
		}
	} else if inputDir != "" {
		files, err = findCSVFiles(inputDir)
		if err != nil {
			return fmt.Errorf("failed to find CSV files: %w", err)
		}
	}

	if len(files) == 0 {
		return fmt.Errorf("no CSV files found to import")
	}

	fmt.Printf("Importing %d file(s) into database: %s\n", len(files), importDBPath)
	fmt.Println()

	// Import each file
	totalCreated := 0
	totalUpdated := 0
	totalSkipped := 0
	totalErrors := 0

	for i, file := range files {
		fileName := filepath.Base(file)
		fmt.Printf("[%d/%d] Importing: %s\n", i+1, len(files), fileName)

		result, err := service.ImportCSVFile(file)
		if err != nil {
			fmt.Printf("  ERROR: %v\n", err)
			totalErrors++
			
			// Move to discards if folder workflow enabled
			if moveFiles {
				discardPath := filepath.Join(targetDiscardsDir, fileName)
				if moveErr := os.Rename(file, discardPath); moveErr != nil {
					fmt.Printf("  WARNING: Failed to move to discards: %v\n", moveErr)
				} else {
					fmt.Printf("  Moved to: %s\n", targetDiscardsDir)
				}
			}
			fmt.Println()
			continue
		}

		fmt.Printf("  Session ID: %s\n", result.SessionID)
		fmt.Printf("  Records created: %d\n", result.RecordsCreated)
		fmt.Printf("  Records updated: %d\n", result.RecordsUpdated)

		if len(result.Errors) > 0 {
			fmt.Printf("  Warnings: %d\n", len(result.Errors))
			for _, errMsg := range result.Errors {
				fmt.Printf("    - %s\n", errMsg)
			}
		}

		totalCreated += result.RecordsCreated
		totalUpdated += result.RecordsUpdated
		totalSkipped += result.RecordsSkipped

		// Move to processed if folder workflow enabled
		if moveFiles {
			processedPath := filepath.Join(targetProcessedDir, fileName)
			if moveErr := os.Rename(file, processedPath); moveErr != nil {
				fmt.Printf("  WARNING: Failed to move to processed: %v\n", moveErr)
			} else {
				fmt.Printf("  Moved to: %s\n", targetProcessedDir)
			}
		}
		
		fmt.Println()
	}

	// Summary
	fmt.Println("Import Summary:")
	fmt.Printf("  Files processed: %d\n", len(files))
	fmt.Printf("  Total records created: %d\n", totalCreated)
	fmt.Printf("  Total records updated: %d\n", totalUpdated)
	fmt.Printf("  Total records skipped: %d\n", totalSkipped)
	if totalErrors > 0 {
		fmt.Printf("  Files with errors: %d\n", totalErrors)
	}

	fmt.Println("\nNext steps:")
	fmt.Println("  - Generate reports: go-sqlite-cli report --help")
	fmt.Println("  - Query data: sqlite3", importDBPath)

	return nil
}

// findCSVFiles finds all CSV files in a directory (non-recursive)
func findCSVFiles(dir string) ([]string, error) {
	var files []string

	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		if strings.HasSuffix(strings.ToLower(entry.Name()), ".csv") {
			files = append(files, filepath.Join(dir, entry.Name()))
		}
	}

	return files, nil
}
