// Copyright 2025 Mihai Ungureanu
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/miun-personal-shadows/seed-go-sqlite-api/internal/database"
	"github.com/miun-personal-shadows/seed-go-sqlite-api/internal/importer"
	"github.com/spf13/cobra"
)

var (
	importDBPath      string
	importFile        string
	importDir         string
	loadReference     bool
	productCodesPath  string
)

// NewImportCmd creates the import command
func NewImportCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "import",
		Short: "Import inspector CSV files into the database",
		Long: `Import CSV files generated by the inspector into the license monitor database.

The import command supports:
- Single file import: --file <path>
- Directory import: --dir <path> (imports all .csv files)
- Automatic node creation if not exists
- Physical host tracking and aggregation
- Import audit trail

Example:
  # Import single file
  go-sqlite-cli import --db-path ./data/license-monitor.db --file ./iwdli_output_omis446_20251021_090906.csv

  # Import all files in directory
  go-sqlite-cli import --db-path ./data/license-monitor.db --dir ./input/`,
		RunE: runImport,
	}

	cmd.Flags().StringVar(&importDBPath, "db-path", "data/license-monitor.db",
		"Path to the SQLite database file")
	cmd.Flags().StringVar(&importFile, "file", "",
		"Path to a single CSV file to import")
	cmd.Flags().StringVar(&importDir, "dir", "",
		"Directory containing CSV files to import")
	cmd.Flags().BoolVar(&loadReference, "load-reference", false,
		"Load reference data (product codes) before importing")
	cmd.Flags().StringVar(&productCodesPath, "product-codes", "",
		"Path to product-codes.csv file (required with --load-reference)")

	return cmd
}

func runImport(cmd *cobra.Command, args []string) error {
	// Validate flags
	if importFile == "" && importDir == "" {
		return fmt.Errorf("either --file or --dir must be specified")
	}

	if importFile != "" && importDir != "" {
		return fmt.Errorf("cannot specify both --file and --dir")
	}

	// Check database exists
	if _, err := os.Stat(importDBPath); os.IsNotExist(err) {
		return fmt.Errorf("database does not exist at %s\nRun 'go-sqlite-cli init' first", importDBPath)
	}

	// Connect to database
	db, err := database.Connect(importDBPath)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	// Load reference data if requested
	if loadReference {
		if productCodesPath == "" {
			return fmt.Errorf("--product-codes must be specified with --load-reference")
		}

		fmt.Println("Loading reference data...")
		loader := importer.NewReferenceDataLoader(db)
		if err := loader.LoadProductCodesCSV(productCodesPath); err != nil {
			return fmt.Errorf("failed to load product codes: %w", err)
		}
		fmt.Println()
	}

	// Create import service
	service := importer.NewImportService(db)

	// Get list of files to import
	var files []string
	if importFile != "" {
		files = []string{importFile}
	} else {
		files, err = findCSVFiles(importDir)
		if err != nil {
			return fmt.Errorf("failed to find CSV files: %w", err)
		}
	}

	if len(files) == 0 {
		return fmt.Errorf("no CSV files found to import")
	}

	fmt.Printf("Importing %d file(s) into database: %s\n", len(files), importDBPath)
	fmt.Println()

	// Import each file
	totalCreated := 0
	totalUpdated := 0
	totalSkipped := 0
	totalErrors := 0

	for i, file := range files {
		fmt.Printf("[%d/%d] Importing: %s\n", i+1, len(files), filepath.Base(file))

		result, err := service.ImportCSVFile(file)
		if err != nil {
			fmt.Printf("  ERROR: %v\n", err)
			totalErrors++
			continue
		}

		fmt.Printf("  Session ID: %s\n", result.SessionID)
		fmt.Printf("  Records created: %d\n", result.RecordsCreated)

		if len(result.Errors) > 0 {
			fmt.Printf("  Warnings: %d\n", len(result.Errors))
			for _, errMsg := range result.Errors {
				fmt.Printf("    - %s\n", errMsg)
			}
		}

		totalCreated += result.RecordsCreated
		totalUpdated += result.RecordsUpdated
		totalSkipped += result.RecordsSkipped
		fmt.Println()
	}

	// Summary
	fmt.Println("Import Summary:")
	fmt.Printf("  Files processed: %d\n", len(files))
	fmt.Printf("  Total records created: %d\n", totalCreated)
	fmt.Printf("  Total records updated: %d\n", totalUpdated)
	fmt.Printf("  Total records skipped: %d\n", totalSkipped)
	if totalErrors > 0 {
		fmt.Printf("  Files with errors: %d\n", totalErrors)
	}

	fmt.Println("\nNext steps:")
	fmt.Println("  - Generate reports: go-sqlite-cli report --help")
	fmt.Println("  - Query data: sqlite3", importDBPath)

	return nil
}

// findCSVFiles finds all CSV files in a directory (non-recursive)
func findCSVFiles(dir string) ([]string, error) {
	var files []string

	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		if strings.HasSuffix(strings.ToLower(entry.Name()), ".csv") {
			files = append(files, filepath.Join(dir, entry.Name()))
		}
	}

	return files, nil
}
